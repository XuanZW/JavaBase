# 第二周-学习总结(2018.07.16 ~ 2018.07.22)
## 课程学习内容
### 07.16
* 代码块: 使用{}括起来的代码成为代码块
    * 静态代码块: 在类中的成员位置，用{}括起来的代码，只不过它用static修饰
    * 构造代码块: 在类中的成员位置，用{}括起来的代码。每次调用构造方法执行前，都会先执行构造代码块。可以把多个构造方法的共同代码放在一起
    * 局部代码块: 局部位置，用于限定变量的生命周期
* 静态代码块、构造代码块、构造方法的执行顺序
    * 静态 -> 构造代码块 -> 构造方法
    * 静态代码块：只执行一次
* `this` 与 `super` 的区别

    |比较项|`this`|`super`|
    |:-|:-|:-|
    |定义|本类对象|父类对象|
    |使用|本类属性、方法、对象|父类属性、方法|
    |查找范围|先从本类查找，找不到去父类查找|直接去父类查找|
    |特殊点|`this`代表当前对象||
* `static` 关键字
    * static保存的位置在全局数据区中也叫类空间中
    * 在静态方法中不允许调用非静态方法或非静态全局变量
* `final` 关键字: 在Java中表示终结器的概念，可以定义类、方法及属性，被`final`修饰的类不能被继承、修饰方法不能被覆写、修饰属性不能被修改（常量）
* 方法的多态
    * 方法的重载
    * 方法的覆写: 名称、参数类型及个数、返回值与父类完全相同，访问权限不能比父类更严格
* 对象的多态
    * 向上转型: 统一标准，使用的方法向父类对齐
    * 向下转型: 子类可以使用自己独特的方法
    * 限制：向下转型必须先向上转型（即创建时发生了自动向上转型）
* `instanceof` 关键字: 判断某个对象是否是其或其子类的实例
* 抽象类: 使用关键字 `abstract`
    * 抽象类不能进行实例化操作
    * 抽象类存在构造方法，因为会被继承，子类在创建实例时会调用父类的构造方法
    * 抽象类不能定义为`final`，它需要子类继承
    * 抽象类中可以只存在普通方法，没有抽象方法
    * 抽象类中可以有静态属性和方法
    * 抽象类的缺点: 受限于Java的单继承、普通类继承抽象类必须覆写所有抽象方法
    * 应用: 模板设计模式
* 接口: 使用关键字 `interface`
    * 定义: 由全部都是抽象方法和全局变量组成的类，1.8以后支持 __默认方法__，可以不实现
    * 作用: 
        * 定义标准
        * 代表能力(行为)
        * 对完暴露的方法
    * 接口允许多继承，一个类可以实现多个接口
    * 抽象类和接口的区别

    |比较项|抽象类|接口|
    |-|-|-|
    |定义|`abstract`|`interface`|
    |组成|普通方法、抽象方法、构造方法和普通属性|抽象方法、全局常量及默认方法|
    |访问权限|public/protected/private|public|
    |关系|一个类能继承一个抽象类|一个类可以实现多个接口|
    |使用|`extends`|`implements`|
    |特殊点||一个接口可以继承多个接口|
* 工厂设计模式: 类与类之间是存在依赖关系的，依赖关系造成耦合度提高，实现解耦的方式就是使用工厂模式
    ```java
    public class TestFactory {
        public static void main(String[] args) {
            Fruit f = FruitFactory.getInstance(args[0]);
            if(f!=null) {
                f.eat();
            } else {
                System.out.println("The fruit is not exists...");
            }
        }
    }
    interface Fruit {
        public void eat();
    }
    class Apple implements Fruit {
        @Override
        public void eat() {
            System.out.println("eat apple...");
        }
    }
    class Pear implements Fruit {
        @Override
        public void eat() {
            System.out.println("eat pear...");
        }
    }
    class FruitFactory {
        public static Fruit getInstance(String name) {
            switch(name) {
                case "apple":
                    return new Apple();
                case "pear":
                    return new Pear();
                default:   
                    return null;
            }
        }
    }
    ```

### 07.17
* 包装类([附`Integer`源码](../course/0717/Integer.java))
    * 装箱(基本->包装): `Integer x = new Integer(5);`
    * 拆箱(包装->基本): `int n = x.intValue();`
    * 在JDK1.5之前，必须使用如上方式装箱、拆箱，在JDK1.5之后，添加了 __自动拆箱和自动装箱__ 的操作
    ```java
    Integer x = 5;
    int n = x;
    ```
    * 包装类与`String`类似，具有对象池的概念
    * 数据转型: 将字符串转换为基本数据类型
        * 调用方法: `Integer.parseInt(s)`
        * 出现异常: if the String does not contain a parsable int, 会抛出`NumberFormatException`异常
* 异常处理
    * 异常处理的一般结构
    ```java
    try{
        // 可能会出现异常的代码
    } catch (NullPointerExcetion e) { // 声明具体的异常类型
        // 对 NullPointerExcetion异常的处理
    } catch(Exception e) { // 可以多层catch异常
        // 对 Exception异常的处理
    } finally {
        // 无论程序正常运行、出现异常或被打断
        // 都一定会执行的代码段
    }
    ```
    * 异常的继承结构
        * `Throwable`
            * `Error`: 表示JVM程序出错，不能被处理的异常
            * `Exception`: 程序中的异常，可以被处理
    * `throws`关键字: 作用于方法，将异常交给调用处处理
    * `throw`关键字: 作用于程序中，抛出某种异常，程序检测到某种异常，需要被处理
    * 注意: 只能在代码中忽略(不处理)`RuntimeException(及其子类)`类型的异常，编译器强制要求对其他类型的处理。
        * 无法预估的错误，比如传递了一个null引用
        * 代码中的错误，比如数组越界
    * 自定义异常
* 包
    * 使用包的目的: 为文件进行分离，相当于操作系统中的文件夹
    * 定义包: `package *(反顺序域名).*(项目名称).*(层次名)`
    * 导入包: 
        * `import *(包名).*(类名)` 
        * `import *(包名).*` 导入该包下所有类
        * 在使用中可以使用全名直接使用该类(一般为解决同名冲突使用)，如`java.util.ArrayList list = new java.util.ArrayList();`
    * 包的访问权限

    ||`public`|`default`|`protected`|`private`|
    |:-:|:-:|:-:|:-:|:-:|
    |本类|✔|✔|✔|✔|
    |同一包的不同类|✔|✔|✔|✘|
    |不同包的子类|✔|✔|✘|✘|
    |不同包的非子类|✔|✘|✘|✘|
    * 命名规范: 反顺序的域名.项目名



### 07.18


### 07.20


### 07.21 







## 自学内容
### 注解
* 元注解: 专职负责注解其他的注解
    * `@Target`: 表示该注解可以用于什么地方，可用的ElementType参数包括：
        * `CONSTRUCTIOR`: 构造器的声明
        * `FIELD`: 域声明(包括enum实例)
        * `LOCAL_VARIABLE`: 局部变量声明
        * `METHOD`: 方法声明
        * `PACKAGE`: 包声明
        * `PARAMETER`: 参数声明
        * `TYPE`: 类、接口(包括注解类型)或enum声明
    * `@Retention`: 表示需要在级别保存该注解类型，可选的RetetionPolicy参数包括：
        * `SOURCE`: 注解将被编译器丢弃
        * `CLASS`: 注解在class文件中可用，但会被VM丢弃
        * `RUNTIME`: VM将在运行期也保留注解，因此可以通过反射机制读取注解的信息
* 注解元素: 注解元素可用的类型如下
    * 所有的基本数据类型(int, float, boolean等)(不允许使用包装类)
    * `String`
    * `Class`
    * `enum`
    * `Annotation`
    * 以上类型的数组
* 定义一个注解，并设置默认值
    ```java
    @Target(ElementType.METHOD)
    @Retention(RetetionPolicy.RUNTIME)
    public @interface @SimulatingNull{
        public int id() default -1;
        public String description() default "";
    }
    ```
* 用法
    * 如果注解中仅有一个元素无默认值（需要赋值），此时无需使用名-值对的这种语法
* 实例: 
    ```java
    /**
     * 模拟JUnit实现单元测试
     */
    @Target(ElementType.METHOD)
    @Retention(RetentionPolicy.RUNTIME)
    @interface Test {}

    /**
     * @Test注解处理器
     */
    class TestProcessor {
        public static void process(Class cl) {
            try {
                Object obj = cl.newInstance();
                for(Method method: cl.getDeclaredMethods()) {
                    // System.out.println("--> "+method.getName());
                    Annotation[] anns = method.getDeclaredAnnotations();
                    if(anns.length < 1)
                        continue;
                    if(anns[0] instanceof Test) {
                        System.out.println("==== [Testing]: " + method.getName() + " ====");
                        try {
                            method.invoke(obj);
                        } catch (java.lang.reflect.InvocationTargetException e) {
                            e.printStackTrace();
                        }
                    }
                }

                System.out.println("==== you have passed this test. ====");
            } catch(InstantiationException|IllegalAccessException e) {
                e.printStackTrace();
            }
        }
    }
    class NeedTest {
        @Test
        public void run() {
            System.out.println("I'm running my Test...");
        }
    }
    public class Client {
        public static void main(String[] args) {
            TestProcessor.process(NeedTest.class);
        }
    }
    ```

### 并发
* `接口Runnable` 和 `类Thread` 的区别
    * `Runnable -> run()`: 不是有单独的线程驱动的，需要依托其他线程
    * `Thread -> run()`: 具有自己的线程
* 使用`Executor`进行并发管理
    * 不使用当前线程的资源
    * 程序会在调用`shutdown()`之前提交的所有任务完成后结束
    * `ExecutorService`:
        * `CachedThreadPool`: 为每一个任务创建一个线程(一般用这个就好)
        * `FixedThreadPool`: 可以控制线程的数量
        * `SingleThreadPool`: 仅有一个线程，类似线程数量为1的`FixedThreadPool`
    ```java
    class LiftOff implements Runnable {
        private static int taskCount = 0;
        private final int id = taskCount++;
        @Override
        public void run() {
            for(int i=0; i<10; i++)
                System.out.println("["+id+"]("+Thread.currentThread().getId()+") " + i);
        }
        public static void main(String[] args) {
            ExecutorService exec = Executors.newCachedThreadPool();
            // ExecutorService exec = Executors.newFixedThreadPool(3); // 使用有限的线程集完成并发
            for(int i=0; i<5; i++)
                exec.execute(new LiftOff());
            // 防止新任务被提交给这个Executor
            exec.shutdown();
        }
    }
    ```
* 线程的一些基本操作
    * 休眠: `Thread.sleep(milliseconds)`: 休眠一段时间，参数为毫秒
    * 优先级
        * 查看优先级: `Thread.currentThread().getPriority()`
        * 设置优先级: `Thread.currentThread().setPriority()`
        * 参数
            * `Thread.MAX_PRIORITY` 最高(10)
            * `Thread.NORM_PRIORITY` 中等(5)
            * `Thread.MIN_PRIORITY` 最低(1)
        * 注意: 尽管JDK有10个优先级，但它与多数操作系统都不能映射得很好。比如Windows7有7个优先级且不固定，所以这种映射关系也不是确定的。唯一可移植的方法是当调整优先级别的时候，只使用`MAX_PRIORITY`、`NORM_PRIORITY`和`MIN_PRIORITY`三种级别。
    * 让步: 使用`Thread.yeild()`进行暗示，申请可以将资源调度给其他线程使用，但系统未必会切换线程 
    * 后台线程
        * 程序在运行时在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分
        * 当所有的非后台线程结束后，程序也就终止了，同时会杀死所有后台进程
        * 将线程设置为后台线程需要在线程启动前设置`thread.setDaemo(true)`



